---
// SketchScrollReveal.astro
// Scroll-driven materialisation for .sketch-illustration images.
// Desktop (>1200px): image wrapped in a fixed-position div in right margin, scrub with GSAP ScrollTrigger.
//   - CSS mask makes white paper background transparent (img.src unchanged)
//   - Wrapper with semi-transparent bg controls how much grid guides show through
// Mobile (<=1200px): image wrapped inline, animates in via IntersectionObserver.
// This is reader-facing (production), NOT dev-only.
---

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  gsap.registerPlugin(ScrollTrigger);

  let markers: HTMLElement[] = [];
  let wrappers: HTMLElement[] = [];
  let observers: IntersectionObserver[] = [];
  let tweens: gsap.core.Tween[] = [];
  let prevImages: HTMLImageElement[] = [];
  let desktopMQListener: (() => void) | null = null;

  /**
   * Apply a mask to hide the white paper background.
   * Uses CSS mask-image so img.src stays untouched (no data URL corruption).
   * The mask alpha channel: 255 for ink lines (visible), 0 for paper (hidden).
   */
  function applyMask(img: HTMLImageElement): void {
    if (img.dataset.maskUrl) {
      img.style.maskImage = `url(${img.dataset.maskUrl})`;
      (img.style as any).webkitMaskImage = `url(${img.dataset.maskUrl})`;
      img.style.maskSize = '100% 100%';
      (img.style as any).webkitMaskSize = '100% 100%';
    }
  }

  async function processImageBackground(img: HTMLImageElement): Promise<void> {
    try {
      if (!img.complete || img.naturalWidth === 0) {
        await new Promise<void>((resolve, reject) => {
          img.addEventListener('load', () => resolve(), { once: true });
          img.addEventListener('error', () => reject(), { once: true });
        });
      }

      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // Build mask: alpha based on original pixel brightness
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2];
        const brightness = (r + g + b) / 3;

        let alpha;
        if (brightness > 240) {
          alpha = 0; // Paper background: fully transparent
        } else if (brightness > 180) {
          alpha = Math.round(255 * (1 - (brightness - 180) / 60));
        } else {
          alpha = 255; // Ink lines: fully opaque
        }

        data[i] = 0;
        data[i + 1] = 0;
        data[i + 2] = 0;
        data[i + 3] = alpha;
      }

      ctx.putImageData(imageData, 0, 0);
      const maskUrl = canvas.toDataURL('image/png');

      // Store mask and apply — img.src stays untouched
      img.dataset.maskUrl = maskUrl;
      applyMask(img);
      img.classList.add('sketch-bg-processed');
    } catch {
      // Canvas failed (CORS etc.) — fall back to mix-blend-mode
    }
  }

  function init() {
    // Process ALL sketch images in background (don't block scroll-reveal setup)
    const allSketchImages = document.querySelectorAll<HTMLImageElement>('.sketch-illustration');
    Array.from(allSketchImages).forEach(img => processImageBackground(img));

    const images = document.querySelectorAll<HTMLImageElement>('.post-content .sketch-illustration');
    const postContent = document.querySelector('.post-content') as HTMLElement;
    if (!postContent) return;

    const desktopMQ = window.matchMedia('(min-width: 1201px)');

    function cleanUp() {
      ScrollTrigger.getAll().forEach(st => st.kill());
      markers.forEach(m => m.remove());
      markers = [];
      observers.forEach(obs => obs.disconnect());
      observers = [];
      tweens.forEach(t => t.kill());
      tweens = [];

      // Unwrap images from wrappers
      wrappers.forEach(wrapper => {
        const img = wrapper.querySelector('.sketch-illustration') as HTMLImageElement;
        if (img && wrapper.parentElement) {
          wrapper.parentElement.insertBefore(img, wrapper);
          wrapper.remove();
        }
      });
      wrappers = [];

      const allImages = new Set([...prevImages, ...Array.from(images)]);
      allImages.forEach(img => {
        gsap.set(img, { clearProps: 'all' });
        img.classList.remove('sketch-reveal-pending');
        // Re-apply mask after GSAP clears inline styles
        applyMask(img);
      });
      prevImages = Array.from(images);
    }

    function wrapImage(img: HTMLImageElement): HTMLElement {
      // Remove loading="lazy" — it prevents images from loading inside
      // opacity:0 fixed-position wrappers (browser thinks they're off-screen)
      img.removeAttribute('loading');

      const wrapper = document.createElement('div');
      wrapper.className = 'sketch-reveal-wrapper';
      img.parentElement!.insertBefore(wrapper, img);
      wrapper.appendChild(img);
      wrappers.push(wrapper);
      return wrapper;
    }

    function findNextTrigger(el: Element): HTMLElement | null {
      let anchor: Element | null = el;
      while (anchor && anchor.parentElement !== postContent) {
        anchor = anchor.parentElement;
      }
      if (!anchor) return null;

      let next = anchor.nextElementSibling;
      while (next) {
        const tag = next.tagName;
        if (tag === 'H1' || tag === 'H2' || tag === 'H3' || tag === 'H4' || tag === 'H5' || tag === 'H6') return next as HTMLElement;
        if (next.classList.contains('sketch-scroll-marker')) return next as HTMLElement;
        next = next.nextElementSibling;
      }
      return null;
    }

    function hasPrecedingImage(el: Element): boolean {
      let anchor: Element | null = el;
      while (anchor && anchor.parentElement !== postContent) {
        anchor = anchor.parentElement;
      }
      if (!anchor) return false;

      let prev = anchor.previousElementSibling;
      while (prev) {
        const tag = prev.tagName;
        if (tag === 'H1' || tag === 'H2' || tag === 'H3' || tag === 'H4' || tag === 'H5' || tag === 'H6') return false;
        if (prev.classList.contains('sketch-scroll-marker')) return true;
        prev = prev.previousElementSibling;
      }
      return false;
    }

    function setupDesktop() {
      const imageArray = Array.from(images);

      imageArray.forEach((img) => {
        const marker = document.createElement('span');
        marker.className = 'sketch-scroll-marker';
        marker.setAttribute('aria-hidden', 'true');
        img.parentElement!.insertBefore(marker, img);
        markers.push(marker);

        const wrapper = wrapImage(img);

        img.style.setProperty('--sketch-blur', '8px');
        gsap.set(wrapper, { opacity: 0, y: 20, yPercent: -50 });

        const nextHeading = findNextTrigger(marker);
        const hasPrec = hasPrecedingImage(marker);

        requestAnimationFrame(() => {
          // If preceded by another image (no heading between), delay fade-in
          // so the previous image fully fades out first (sequential, no overlap)
          gsap.timeline({
            scrollTrigger: {
              trigger: marker,
              start: hasPrec ? 'top 70%' : 'top bottom',
              end: hasPrec ? 'top 45%' : 'top 60%',
              scrub: true,
            }
          })
          .fromTo(wrapper,
            { opacity: 0, y: 20, yPercent: -50 },
            { opacity: 1, y: 0, yPercent: -50, ease: 'none' },
            0
          )
          .fromTo(img,
            { '--sketch-blur': '8px' },
            { '--sketch-blur': '0px', ease: 'none' },
            0
          );

          if (nextHeading) {
            const isNextImage = nextHeading.classList.contains('sketch-scroll-marker');
            // If next trigger is another image: fade out early so it completes
            // before the next image starts fading in (sequential transitions)
            gsap.timeline({
              scrollTrigger: {
                trigger: nextHeading,
                start: isNextImage ? 'top bottom' : 'top 70%',
                end: isNextImage ? 'top 70%' : 'top 30%',
                scrub: true,
              }
            })
            .to(wrapper, { opacity: 0, y: -20, yPercent: -50, ease: 'none' }, 0)
            .to(img, { '--sketch-blur': '8px', ease: 'none' }, 0);
          } else {
            gsap.timeline({
              scrollTrigger: {
                trigger: postContent,
                start: 'bottom bottom',
                end: 'bottom 30%',
                scrub: true,
              }
            })
            .to(wrapper, { opacity: 0, y: -20, yPercent: -50, ease: 'none' }, 0)
            .to(img, { '--sketch-blur': '8px', ease: 'none' }, 0);
          }
        });
      });
    }

    function setupMobile() {
      images.forEach(img => {
        const wrapper = wrapImage(img);

        img.classList.add('sketch-reveal-pending');
        gsap.set(img, { opacity: 0, y: 20, '--sketch-blur': '8px' });

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const tween = gsap.to(img, {
                  opacity: 1,
                  y: 0,
                  '--sketch-blur': '0px',
                  duration: 0.6,
                  ease: 'power2.out',
                  onComplete: () => img.classList.remove('sketch-reveal-pending'),
                });
                tweens.push(tween);
              } else {
                const tween = gsap.to(img, {
                  opacity: 0,
                  y: 20,
                  '--sketch-blur': '8px',
                  duration: 0.4,
                  ease: 'power2.in',
                  onComplete: () => img.classList.add('sketch-reveal-pending'),
                });
                tweens.push(tween);
              }
            });
          },
          { threshold: 0.3 }
        );

        observer.observe(wrapper);
        observers.push(observer);
      });
    }

    function setup() {
      cleanUp();
      if (desktopMQ.matches) {
        setupDesktop();
      } else {
        setupMobile();
      }
    }

    if (desktopMQListener) {
      desktopMQ.removeEventListener('change', desktopMQListener);
    }
    desktopMQListener = setup;

    setup();
    desktopMQ.addEventListener('change', setup);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  window.addEventListener('sketch-reveal-refresh', () => {
    init();
  });
</script>
