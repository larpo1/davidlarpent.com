---
// SketchScrollReveal.astro
// Scroll-driven materialisation for .sketch-illustration images.
// Desktop (>1200px): image goes position:fixed in right margin, scrub with GSAP ScrollTrigger.
//   - Fades in when the image's section text hits the fold
//   - Stays visible while reading that section
//   - Fades out when the next section heading reaches the bottom of the fold
// Mobile (<=1200px): image stays inline, animates in via IntersectionObserver.
// No cloning -- same element, different positioning via CSS media queries.
// This is reader-facing (production), NOT dev-only.
---

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  gsap.registerPlugin(ScrollTrigger);

  // Track state at module level so refresh can clean up previous run
  let markers: HTMLElement[] = [];
  let observers: IntersectionObserver[] = [];
  let tweens: gsap.core.Tween[] = [];
  let prevImages: HTMLImageElement[] = [];
  let desktopMQListener: (() => void) | null = null;

  function init() {
    const images = document.querySelectorAll<HTMLImageElement>('.post-content .sketch-illustration');

    const postContent = document.querySelector('.post-content') as HTMLElement;
    if (!postContent) return;

    const desktopMQ = window.matchMedia('(min-width: 1201px)');

    function cleanUp() {
      ScrollTrigger.getAll().forEach(st => st.kill());
      markers.forEach(m => m.remove());
      markers = [];
      observers.forEach(obs => obs.disconnect());
      observers = [];
      tweens.forEach(t => t.kill());
      tweens = [];
      // Clean up both previous and current images (handles removed images)
      const allImages = new Set([...prevImages, ...Array.from(images)]);
      allImages.forEach(img => {
        gsap.set(img, { clearProps: 'all' });
        img.classList.remove('sketch-reveal-pending');
        img.classList.remove('sketch-reveal-active');
      });
      prevImages = Array.from(images);
    }

    // Find the next heading (h2/h3) after a given element in the post content
    function findNextHeading(el: Element): HTMLElement | null {
      // Walk up to find the direct child of .post-content that contains el
      let anchor: Element | null = el;
      while (anchor && anchor.parentElement !== postContent) {
        anchor = anchor.parentElement;
      }
      // If el IS a direct child of postContent, anchor is el itself
      // If el is not inside postContent at all, anchor is null
      if (!anchor) return null;

      // Walk forward through siblings looking for a heading
      let next = anchor.nextElementSibling;
      while (next) {
        const tag = next.tagName;
        if (tag === 'H1' || tag === 'H2' || tag === 'H3') return next as HTMLElement;
        next = next.nextElementSibling;
      }
      return null;
    }

    function setupDesktop() {
      const imageArray = Array.from(images);

      imageArray.forEach((img) => {
        img.classList.add('sketch-reveal-active');

        // Insert a zero-height marker where the image sits in the DOM.
        // ScrollTrigger uses this marker to know when to animate,
        // since the image itself is position:fixed and has no scroll position.
        const marker = document.createElement('span');
        marker.className = 'sketch-scroll-marker';
        marker.setAttribute('aria-hidden', 'true');
        img.parentElement!.insertBefore(marker, img);
        markers.push(marker);

        // Set initial state (yPercent: -50 keeps image vertically centered with top: 50%)
        img.style.setProperty('--sketch-blur', '8px');
        gsap.set(img, { opacity: 0, y: 20, yPercent: -50 });

        // Find the next section heading after this image
        const nextHeading = findNextHeading(marker);

        requestAnimationFrame(() => {
          // FADE IN: as the image's section text hits the fold (scrolling down)
          // Starts when marker reaches bottom of viewport, fully visible by 30% from top
          gsap.timeline({
            scrollTrigger: {
              trigger: marker,
              start: 'top bottom',
              end: 'top 30%',
              scrub: true,
            }
          }).fromTo(img,
            { '--sketch-blur': '8px', opacity: 0, y: 20, yPercent: -50 },
            { '--sketch-blur': '0px', opacity: 1, y: 0, yPercent: -50, ease: 'none' }
          );

          // FADE OUT: when the next section heading approaches the fold
          if (nextHeading) {
            gsap.timeline({
              scrollTrigger: {
                trigger: nextHeading,
                start: 'top 120%',
                end: 'top 50%',
                scrub: true,
              }
            }).to(img, {
              '--sketch-blur': '8px',
              opacity: 0,
              y: -20,
              yPercent: -50,
              ease: 'none',
            });
          } else {
            // Last section: fade out near end of article
            gsap.timeline({
              scrollTrigger: {
                trigger: postContent,
                start: 'bottom bottom',
                end: 'bottom 30%',
                scrub: true,
              }
            }).to(img, {
              '--sketch-blur': '8px',
              opacity: 0,
              y: -20,
              yPercent: -50,
              ease: 'none',
            });
          }
        });
      });
    }

    function setupMobile() {
      images.forEach(img => {
        img.classList.add('sketch-reveal-pending');
        gsap.set(img, { opacity: 0, y: 20, '--sketch-blur': '8px' });

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const tween = gsap.to(img, {
                  opacity: 1,
                  y: 0,
                  '--sketch-blur': '0px',
                  duration: 0.6,
                  ease: 'power2.out',
                  onComplete: () => img.classList.remove('sketch-reveal-pending'),
                });
                tweens.push(tween);
              } else {
                const tween = gsap.to(img, {
                  opacity: 0,
                  y: 20,
                  '--sketch-blur': '8px',
                  duration: 0.4,
                  ease: 'power2.in',
                  onComplete: () => img.classList.add('sketch-reveal-pending'),
                });
                tweens.push(tween);
              }
            });
          },
          { threshold: 0.3 }
        );

        observer.observe(img);
        observers.push(observer);
      });
    }

    function setup() {
      cleanUp();
      if (desktopMQ.matches) {
        setupDesktop();
      } else {
        setupMobile();
      }
    }

    // Remove previous matchMedia listener if re-running init
    if (desktopMQListener) {
      desktopMQ.removeEventListener('change', desktopMQListener);
    }
    desktopMQListener = setup;

    setup();
    desktopMQ.addEventListener('change', setup);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Allow re-initialisation when images are added/removed/replaced
  window.addEventListener('sketch-reveal-refresh', () => {
    init();
  });
</script>
