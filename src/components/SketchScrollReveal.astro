---
// SketchScrollReveal.astro
// Scroll-driven materialisation for .sketch-illustration images.
// Desktop (>1200px): image wrapped in a fixed-position div in right margin, scrub with GSAP ScrollTrigger.
//   - Canvas processing removes white background → true transparency
//   - Wrapper with semi-transparent bg controls how much grid guides show through
//   - Fades in when the image's section text hits the fold
//   - Stays visible while reading that section
//   - Fades out when the next section heading reaches the bottom of the fold
// Mobile (<=1200px): image wrapped inline, animates in via IntersectionObserver.
// This is reader-facing (production), NOT dev-only.
---

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  gsap.registerPlugin(ScrollTrigger);

  // Track state at module level so refresh can clean up previous run
  let markers: HTMLElement[] = [];
  let wrappers: HTMLElement[] = [];
  let observers: IntersectionObserver[] = [];
  let tweens: gsap.core.Tween[] = [];
  let prevImages: HTMLImageElement[] = [];
  let desktopMQListener: (() => void) | null = null;

  /**
   * Process a sketch image to make its white/near-white background transparent.
   * After processing, CSS filter: invert(1) handles colour inversion and the
   * wrapper's semi-transparent background controls how much grid guides bleed through.
   */
  async function processImageBackground(img: HTMLImageElement): Promise<void> {
    try {
      // Wait for the image to load if it hasn't already
      if (!img.complete || img.naturalWidth === 0) {
        await new Promise<void>((resolve, reject) => {
          img.addEventListener('load', () => resolve(), { once: true });
          img.addEventListener('error', () => reject(), { once: true });
        });
      }

      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2];
        const brightness = (r + g + b) / 3;

        if (brightness > 240) {
          // Near-white (paper background): fully transparent
          data[i + 3] = 0;
        } else if (brightness > 180) {
          // Anti-aliased edges: gradual transparency
          const t = (brightness - 180) / 60; // 0 at 180, 1 at 240
          data[i + 3] = Math.round(255 * (1 - t));
        }
        // Dark pixels (ink lines): stay fully opaque
      }

      ctx.putImageData(imageData, 0, 0);
      img.src = canvas.toDataURL('image/png');
      img.classList.add('sketch-bg-processed');
    } catch {
      // Canvas processing failed (CORS, etc.) — fall back to mix-blend-mode
    }
  }

  async function init() {
    // Process ALL sketch images (including feature image outside .post-content)
    const allSketchImages = document.querySelectorAll<HTMLImageElement>('.sketch-illustration');
    await Promise.all(Array.from(allSketchImages).map(processImageBackground));

    const images = document.querySelectorAll<HTMLImageElement>('.post-content .sketch-illustration');
    const postContent = document.querySelector('.post-content') as HTMLElement;
    if (!postContent) return;

    const desktopMQ = window.matchMedia('(min-width: 1201px)');

    function cleanUp() {
      ScrollTrigger.getAll().forEach(st => st.kill());
      markers.forEach(m => m.remove());
      markers = [];
      observers.forEach(obs => obs.disconnect());
      observers = [];
      tweens.forEach(t => t.kill());
      tweens = [];

      // Unwrap images from wrappers
      wrappers.forEach(wrapper => {
        const img = wrapper.querySelector('.sketch-illustration') as HTMLImageElement;
        if (img && wrapper.parentElement) {
          wrapper.parentElement.insertBefore(img, wrapper);
          wrapper.remove();
        }
      });
      wrappers = [];

      // Clean up both previous and current images (handles removed images)
      const allImages = new Set([...prevImages, ...Array.from(images)]);
      allImages.forEach(img => {
        gsap.set(img, { clearProps: 'all' });
        img.classList.remove('sketch-reveal-pending');
      });
      prevImages = Array.from(images);
    }

    // Create a wrapper div around an image for blend-mode isolation
    function wrapImage(img: HTMLImageElement): HTMLElement {
      const wrapper = document.createElement('div');
      wrapper.className = 'sketch-reveal-wrapper';
      img.parentElement!.insertBefore(wrapper, img);
      wrapper.appendChild(img);
      wrappers.push(wrapper);
      return wrapper;
    }

    // Find the next heading or sketch marker after a given element in the post content.
    function findNextTrigger(el: Element): HTMLElement | null {
      let anchor: Element | null = el;
      while (anchor && anchor.parentElement !== postContent) {
        anchor = anchor.parentElement;
      }
      if (!anchor) return null;

      let next = anchor.nextElementSibling;
      while (next) {
        const tag = next.tagName;
        if (tag === 'H1' || tag === 'H2' || tag === 'H3' || tag === 'H4' || tag === 'H5' || tag === 'H6') return next as HTMLElement;
        if (next.classList.contains('sketch-scroll-marker')) return next as HTMLElement;
        next = next.nextElementSibling;
      }
      return null;
    }

    function setupDesktop() {
      const imageArray = Array.from(images);

      imageArray.forEach((img) => {
        // Insert a zero-height marker where the image sits in the DOM.
        const marker = document.createElement('span');
        marker.className = 'sketch-scroll-marker';
        marker.setAttribute('aria-hidden', 'true');
        img.parentElement!.insertBefore(marker, img);
        markers.push(marker);

        // Wrap the image for background isolation
        const wrapper = wrapImage(img);

        // Set initial state on wrapper (positioning + visibility)
        img.style.setProperty('--sketch-blur', '8px');
        gsap.set(wrapper, { opacity: 0, y: 20, yPercent: -50 });

        const nextHeading = findNextTrigger(marker);

        requestAnimationFrame(() => {
          // FADE IN
          gsap.timeline({
            scrollTrigger: {
              trigger: marker,
              start: 'top bottom',
              end: 'top 60%',
              scrub: true,
            }
          })
          .fromTo(wrapper,
            { opacity: 0, y: 20, yPercent: -50 },
            { opacity: 1, y: 0, yPercent: -50, ease: 'none' },
            0
          )
          .fromTo(img,
            { '--sketch-blur': '8px' },
            { '--sketch-blur': '0px', ease: 'none' },
            0
          );

          // FADE OUT
          if (nextHeading) {
            gsap.timeline({
              scrollTrigger: {
                trigger: nextHeading,
                start: 'top 70%',
                end: 'top 30%',
                scrub: true,
              }
            })
            .to(wrapper, { opacity: 0, y: -20, yPercent: -50, ease: 'none' }, 0)
            .to(img, { '--sketch-blur': '8px', ease: 'none' }, 0);
          } else {
            gsap.timeline({
              scrollTrigger: {
                trigger: postContent,
                start: 'bottom bottom',
                end: 'bottom 30%',
                scrub: true,
              }
            })
            .to(wrapper, { opacity: 0, y: -20, yPercent: -50, ease: 'none' }, 0)
            .to(img, { '--sketch-blur': '8px', ease: 'none' }, 0);
          }
        });
      });
    }

    function setupMobile() {
      images.forEach(img => {
        // Wrap for background isolation
        const wrapper = wrapImage(img);

        img.classList.add('sketch-reveal-pending');
        gsap.set(img, { opacity: 0, y: 20, '--sketch-blur': '8px' });

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const tween = gsap.to(img, {
                  opacity: 1,
                  y: 0,
                  '--sketch-blur': '0px',
                  duration: 0.6,
                  ease: 'power2.out',
                  onComplete: () => img.classList.remove('sketch-reveal-pending'),
                });
                tweens.push(tween);
              } else {
                const tween = gsap.to(img, {
                  opacity: 0,
                  y: 20,
                  '--sketch-blur': '8px',
                  duration: 0.4,
                  ease: 'power2.in',
                  onComplete: () => img.classList.add('sketch-reveal-pending'),
                });
                tweens.push(tween);
              }
            });
          },
          { threshold: 0.3 }
        );

        observer.observe(wrapper);
        observers.push(observer);
      });
    }

    function setup() {
      cleanUp();
      if (desktopMQ.matches) {
        setupDesktop();
      } else {
        setupMobile();
      }
    }

    if (desktopMQListener) {
      desktopMQ.removeEventListener('change', desktopMQListener);
    }
    desktopMQListener = setup;

    setup();
    desktopMQ.addEventListener('change', setup);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }

  window.addEventListener('sketch-reveal-refresh', () => {
    init();
  });
</script>
