---
interface Props {
  fieldName: 'title' | 'description' | 'content';
  initialContent: string;
  placeholder?: string;
  singleLine?: boolean;
}

const { fieldName, initialContent, placeholder, singleLine = false } = Astro.props;
const editorId = `editor-${fieldName}`;
---

<div
  id={editorId}
  class={`tiptap-editor tiptap-${fieldName}`}
  data-field={fieldName}
  data-single-line={singleLine}
  data-placeholder={placeholder}
>{singleLine ? <p>{initialContent}</p> : <Fragment set:html={initialContent} />}</div>

{fieldName === 'content' && (
  <div id="editor-toolbar" class="editor-toolbar" style="display: none;">
    <button data-action="bold" title="Bold (Ctrl+B)"><strong>B</strong></button>
    <button data-action="italic" title="Italic (Ctrl+I)"><em>I</em></button>
    <button data-action="link" title="Add Link (Ctrl+K)">ðŸ”—</button>
    <button data-action="heading2" title="Heading 2">H2</button>
    <button data-action="heading3" title="Heading 3">H3</button>
    <button data-action="code" title="Code">&lt;/&gt;</button>
    <button data-action="bulletList" title="Bullet List">â€¢ List</button>
    <button data-action="codeBlock" title="Code Block">Code Block</button>
  </div>
)}

<style>
  .tiptap-editor {
    outline: 2px dashed transparent;
    outline-offset: 4px;
    transition: outline-color 0.2s ease;
    border-radius: 4px;
    min-height: 2em;
  }

  .tiptap-editor:hover {
    outline-color: var(--color-border);
  }

  .tiptap-editor :global(.ProseMirror-focused) {
    outline-color: var(--color-link);
    outline-style: solid;
  }

  /* Toolbar */
  .editor-toolbar {
    position: absolute;
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: 0.5rem;
    display: flex;
    gap: 0.25rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000;
  }

  .editor-toolbar button {
    background: transparent;
    border: none;
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    color: var(--color-text);
    transition: background 0.2s;
  }

  .editor-toolbar button:hover {
    background: var(--color-code-bg);
  }

  .editor-toolbar button.is-active {
    background: var(--color-link);
    color: white;
  }

  /* Title/Description - single line */
  /* Title - match post-title styles */
  .tiptap-title {
    font-size: 2.4rem;
    font-weight: 600;
    line-height: 1.3;
    margin: 0;
  }

  .tiptap-title :global(p) {
    margin: 0;
  }

  /* Description - match post-description styles */
  .tiptap-description {
    color: var(--color-text-light);
    font-size: 1rem;
    margin: 0.5rem 0 1rem;
    font-style: italic;
  }

  .tiptap-description :global(p) {
    margin: 0;
  }

  /* Content - full editing */
  .tiptap-content {
    /* Inherits all post-content styles */
  }
</style>

<script>
  import { Editor } from '@tiptap/core';
  import StarterKit from '@tiptap/starter-kit';
  import Link from '@tiptap/extension-link';
  import Placeholder from '@tiptap/extension-placeholder';
  import { Markdown } from 'tiptap-markdown';
  import { Node } from '@tiptap/core';

  // Custom Footnote Extension - renders footnotes as non-editable nodes
  const FootnoteReference = Node.create({
    name: 'footnoteRef',

    group: 'inline',
    inline: true,
    atom: true,

    addAttributes() {
      return {
        id: {
          default: null,
        },
      };
    },

    parseHTML() {
      return [
        {
          tag: 'sup[data-footnote-ref]',
        },
      ];
    },

    renderHTML({ HTMLAttributes }) {
      return ['sup', { 'data-footnote-ref': '', class: 'footnote-ref' }, `[${HTMLAttributes.id}]`];
    },

    addNodeView() {
      return ({ node }) => {
        const dom = document.createElement('sup');
        dom.className = 'footnote-ref';
        dom.textContent = `[${node.attrs.id}]`;
        dom.contentEditable = 'false'; // Make non-editable
        dom.style.opacity = '0.7';
        dom.style.cursor = 'not-allowed';
        dom.title = 'Footnotes cannot be edited inline';
        return { dom };
      };
    },
  });

  // Editor instances stored globally (accessible by save function)
  declare global {
    interface Window {
      editors: Record<string, Editor>;
    }
  }

  window.editors = window.editors || {};

  document.addEventListener('DOMContentLoaded', () => {
    const editorElements = document.querySelectorAll('.tiptap-editor');

    editorElements.forEach((element) => {
      const fieldName = element.getAttribute('data-field') as string;
      const singleLine = element.getAttribute('data-single-line') === 'true';
      const placeholderText = element.getAttribute('data-placeholder') || 'Type something...';
      // Read the server-rendered HTML content before Tiptap replaces it
      const initialContent = element.innerHTML.trim();

      // Configure extensions
      const extensions = [
        StarterKit.configure({
          heading: singleLine ? false : { levels: [2, 3] }, // Only H2/H3 for content
          paragraph: true,
          bold: true,
          italic: true,
          code: true,
          codeBlock: !singleLine,
          bulletList: !singleLine,
          orderedList: !singleLine,
          blockquote: !singleLine,
        }),
        Link.configure({
          openOnClick: false,
          HTMLAttributes: {
            class: null, // Remove default classes
          },
        }),
        Placeholder.configure({
          placeholder: placeholderText,
        }),
        // Markdown extension commented out for testing - may interfere with HTML parsing
        // Markdown.configure({
        //   html: true,
        //   transformCopiedText: true,
        // }),
        FootnoteReference, // Custom footnote node
      ];

      // Clear element before Tiptap mounts (we've already captured the content)
      element.innerHTML = '';

      // Create editor instance with the captured HTML content
      const editor = new Editor({
        element: element as HTMLElement,
        extensions: extensions,
        content: initialContent,
        editorProps: {
          attributes: {
            class: `${fieldName === 'content' ? 'post-content' : ''}`,
          },
          handleKeyDown: (view, event) => {
            // Prevent Enter key in single-line mode
            if (singleLine && event.key === 'Enter') {
              event.preventDefault();
              return true;
            }
            return false;
          },
        },
        onUpdate: () => {
          // Show toolbar when content editor has selection
          if (fieldName === 'content') {
            const { from, to } = editor.state.selection;
            const toolbar = document.getElementById('editor-toolbar');

            if (from !== to && toolbar) {
              // Text is selected - show toolbar
              const coords = editor.view.coordsAtPos(from);
              toolbar.style.display = 'flex';
              toolbar.style.top = `${coords.top - 50}px`;
              toolbar.style.left = `${coords.left}px`;
              toolbar.style.transform = 'translateX(-50%)';
            } else if (toolbar) {
              toolbar.style.display = 'none';
            }
          }
        },
        onSelectionUpdate: () => {
          // Update toolbar button states on selection change
          if (fieldName === 'content') {
            const toolbar = document.getElementById('editor-toolbar');
            if (toolbar) {
              updateToolbarState(editor, toolbar);
            }
          }
        },
      });

      // Store editor instance
      window.editors[fieldName] = editor;

      // Toolbar button handlers (for content editor only)
      if (fieldName === 'content') {
        const toolbar = document.getElementById('editor-toolbar');
        toolbar?.addEventListener('click', (e) => {
          const button = (e.target as HTMLElement).closest('button');
          if (!button) return;

          const action = button.getAttribute('data-action');

          switch (action) {
            case 'bold':
              editor.chain().focus().toggleBold().run();
              break;
            case 'italic':
              editor.chain().focus().toggleItalic().run();
              break;
            case 'link':
              const url = prompt('Enter URL:');
              if (url) {
                editor.chain().focus().setLink({ href: url }).run();
              }
              break;
            case 'heading2':
              editor.chain().focus().toggleHeading({ level: 2 }).run();
              break;
            case 'heading3':
              editor.chain().focus().toggleHeading({ level: 3 }).run();
              break;
            case 'code':
              editor.chain().focus().toggleCode().run();
              break;
            case 'bulletList':
              editor.chain().focus().toggleBulletList().run();
              break;
            case 'codeBlock':
              editor.chain().focus().toggleCodeBlock().run();
              break;
          }

          // Update button active states
          updateToolbarState(editor, toolbar);
        });
      }
    });
  });

  function updateToolbarState(editor: Editor, toolbar: HTMLElement) {
    toolbar.querySelectorAll('button').forEach((button) => {
      const action = button.getAttribute('data-action');
      let isActive = false;

      switch (action) {
        case 'bold':
          isActive = editor.isActive('bold');
          break;
        case 'italic':
          isActive = editor.isActive('italic');
          break;
        case 'link':
          isActive = editor.isActive('link');
          break;
        case 'heading2':
          isActive = editor.isActive('heading', { level: 2 });
          break;
        case 'heading3':
          isActive = editor.isActive('heading', { level: 3 });
          break;
        case 'code':
          isActive = editor.isActive('code');
          break;
        case 'bulletList':
          isActive = editor.isActive('bulletList');
          break;
        case 'codeBlock':
          isActive = editor.isActive('codeBlock');
          break;
      }

      button.classList.toggle('is-active', isActive);
    });
  }
</script>
