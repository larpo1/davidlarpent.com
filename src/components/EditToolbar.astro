---
// Floating WYSIWYG toolbar component using execCommand
// Link creation uses an inline input instead of prompt() to preserve selection
---

<div id="edit-toolbar" class="edit-toolbar" style="display: none;">
  <button data-command="bold" title="Bold (Ctrl+B)"><strong>B</strong></button>
  <button data-command="italic" title="Italic (Ctrl+I)"><em>I</em></button>
  <button data-command="createLink" title="Add Link (Ctrl+K)">L</button>
  <button data-command="formatBlock" data-value="h2" title="Heading 2">2</button>
  <button data-command="formatBlock" data-value="h3" title="Heading 3">3</button>
  <button data-command="insertUnorderedList" title="Bullet List">â€¢</button>
  <button data-command="formatBlock" data-value="pre" title="Code Block">&lt;&gt;</button>
</div>

<div id="link-input-popover" class="link-input-popover" style="display: none;">
  <input type="text" id="link-url-input" placeholder="Enter URL and press Enter" />
</div>

<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    const toolbar = document.getElementById('edit-toolbar');
    const linkPopover = document.getElementById('link-input-popover');
    const linkInput = document.getElementById('link-url-input');
    const contentEditable = document.querySelector('[contenteditable][data-field="content"]') || document.querySelector('[contenteditable][data-field="about"]');

    if (!toolbar || !contentEditable || !linkPopover || !linkInput) return;

    // Saved selection range for link creation
    var savedLinkRange = null;

    // Show toolbar on text selection
    document.addEventListener('selectionchange', () => {
      // Don't hide toolbar while link input is visible
      if (linkPopover.style.display !== 'none') return;

      const selection = window.getSelection();
      if (!selection || selection.isCollapsed || !contentEditable.contains(selection.anchorNode)) {
        toolbar.style.display = 'none';
        return;
      }

      // Position toolbar to the LEFT of content, inline with selection
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      const contentRect = contentEditable.getBoundingClientRect();

      toolbar.style.display = 'flex';
      toolbar.style.flexDirection = 'column'; // Vertical stack
      toolbar.style.top = `${rect.top + window.scrollY}px`; // Inline with selection
      toolbar.style.left = `${contentRect.left - 36}px`; // Position in left margin
      toolbar.style.transform = 'translateX(-100%)'; // Push fully left of anchor point

      // Update button active states
      updateToolbarState(toolbar);
    });

    // Prevent toolbar from stealing focus/selection from contenteditable
    toolbar.addEventListener('mousedown', (e) => {
      e.preventDefault();
    });

    // Show inline link input, saving the current selection
    function showLinkInput() {
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) return;
      savedLinkRange = sel.getRangeAt(0).cloneRange();

      // Position popover near the toolbar
      var toolbarRect = toolbar.getBoundingClientRect();
      linkPopover.style.top = `${toolbarRect.bottom + window.scrollY + 4}px`;
      linkPopover.style.left = `${toolbarRect.left + window.scrollX}px`;
      linkPopover.style.display = 'block';
      linkInput.value = '';
      linkInput.focus();
    }

    // Apply the saved link and close popover
    function applyLink(url) {
      linkPopover.style.display = 'none';
      if (!url || !savedLinkRange) {
        contentEditable.focus();
        return;
      }
      contentEditable.focus();
      var sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(savedLinkRange);
      document.execCommand('createLink', false, url);
      savedLinkRange = null;
      updateToolbarState(toolbar);
    }

    // Cancel link input
    function cancelLinkInput() {
      linkPopover.style.display = 'none';
      if (savedLinkRange) {
        contentEditable.focus();
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(savedLinkRange);
        savedLinkRange = null;
      }
    }

    // Link input keyboard handling
    linkInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        applyLink(linkInput.value.trim());
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelLinkInput();
      }
    });

    // Close link input on blur (e.g. clicking elsewhere)
    linkInput.addEventListener('blur', () => {
      // Small delay to allow Enter keydown to fire first
      setTimeout(() => {
        if (linkPopover.style.display !== 'none') {
          cancelLinkInput();
        }
      }, 150);
    });

    // Handle toolbar button clicks
    toolbar.addEventListener('click', (e) => {
      const button = e.target.closest('button');
      if (!button) return;

      const command = button.getAttribute('data-command');
      const value = button.getAttribute('data-value');

      if (command === 'createLink') {
        showLinkInput();
      } else if (value) {
        document.execCommand(command, false, value);
      } else {
        document.execCommand(command, false, '');
      }

      updateToolbarState(toolbar);
    });

    // Keyboard shortcuts: Ctrl+B, Ctrl+I, Ctrl+K
    document.addEventListener('keydown', (e) => {
      if (!e.ctrlKey && !e.metaKey) return;

      // Only apply if focus is in content area
      const selection = window.getSelection();
      if (!selection || !contentEditable.contains(selection.anchorNode)) return;

      switch(e.key.toLowerCase()) {
        case 'b':
          e.preventDefault();
          document.execCommand('bold');
          break;
        case 'i':
          e.preventDefault();
          document.execCommand('italic');
          break;
        case 'k':
          e.preventDefault();
          showLinkInput();
          break;
      }

      updateToolbarState(toolbar);
    });
  });

  function updateToolbarState(toolbar) {
    toolbar.querySelectorAll('button').forEach(button => {
      const command = button.getAttribute('data-command');
      if (!command) return;

      // formatBlock doesn't have a queryCommandState, so only check simple commands
      if (command === 'formatBlock') {
        button.classList.remove('is-active');
        return;
      }

      const isActive = document.queryCommandState(command);
      button.classList.toggle('is-active', isActive);
    });
  }
</script>

<style>
  .edit-toolbar {
    position: absolute;
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    padding: 0.2rem;
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 1000;
  }

  .edit-toolbar button {
    background: transparent;
    border: none;
    padding: 0.2rem;
    width: 1.4rem;
    height: 1.4rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.65rem;
    color: var(--color-text);
    transition: background 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
  }

  .edit-toolbar button:hover {
    background: var(--color-code-bg);
  }

  .edit-toolbar button.is-active {
    background: #6ba4ff;
    color: white;
  }

  .link-input-popover {
    position: absolute;
    z-index: 1001;
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    padding: 0.3rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  .link-input-popover input {
    background: var(--color-code-bg);
    border: 1px solid var(--color-border);
    border-radius: 3px;
    color: var(--color-text);
    font-size: 0.75rem;
    padding: 0.3rem 0.4rem;
    width: 220px;
    outline: none;
  }

  .link-input-popover input:focus {
    border-color: #6ba4ff;
  }
</style>
