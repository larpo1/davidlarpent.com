---
import { getCollection } from 'astro:content';
import * as fs from 'fs/promises';
import * as path from 'path';
import matter from 'gray-matter';
import Base from '../../layouts/Base.astro';
import AddNotePanel from '../../components/AddNotePanel.astro';
import SourceSettingsPanel from '../../components/SourceSettingsPanel.astro';
import { parseNotes } from '../../lib/parse-notes';

const isDev = import.meta.env.DEV;

export async function getStaticPaths() {
  const allSources = await getCollection('sources');
  return allSources.map(source => ({
    params: { slug: source.slug },
    props: { source },
  }));
}

const { source } = Astro.props;

// Read raw markdown to parse notes
const sourcesDir = path.join(process.cwd(), 'src', 'content', 'sources');
const filePath = path.join(sourcesDir, `${source.slug}.md`);
const rawContent = await fs.readFile(filePath, 'utf-8');
const parsed = matter(rawContent);
const allNotes = parseNotes(parsed.content);

// In production, only show published notes
const notes = isDev ? allNotes : allNotes.filter(n => n.published);

// Source tags are computed as the union of all note tags
const computedTags = [...new Set(allNotes.flatMap(n => n.tags))].sort();

// Collect all existing tags across posts and sources for autocomplete
const allPosts = await getCollection('posts');
const allSources = await getCollection('sources');
const allExistingTags = [...new Set([
  ...allPosts.flatMap(p => p.data.tags || []),
  ...allSources.flatMap(s => s.data.tags || []),
  ...allNotes.flatMap(n => n.tags),
])].map(t => t.toLowerCase()).sort();

const formattedDate = source.data.date.toLocaleDateString('en-US', {
  year: 'numeric',
  month: 'short',
  day: 'numeric'
});

const isoDate = source.data.date.toISOString().split('T')[0];
const isArchived = source.data.archived ?? false;
const sourceTypes = ['book', 'article', 'paper', 'podcast'];
---

<Base
  title={`${source.data.title} | David Larpent`}
  description={`Notes on ${source.data.title} by ${source.data.author}`}
>
  <div class:list={['source-detail', { 'source-archived': isArchived }]}>
    <header class="source-header">
      <span
        class:list={['source-type-badge', { 'source-type-editable': isDev }]}
        id="source-type"
        data-types={JSON.stringify(sourceTypes)}
      >{source.data.type}</span>

      <h1 class="source-title" contenteditable={isDev ? 'true' : undefined} id="source-title">{source.data.title}</h1>

      <p class="source-author-line">
        {isDev ? (
          <span contenteditable="true" id="source-author">{source.data.author}</span>
        ) : (
          <Fragment>{source.data.author}</Fragment>
        )}
        &middot;
        <span class:list={['source-date-display', { 'source-date-editable': isDev }]} id="source-date-display">{formattedDate}</span>
        {isDev && <input type="date" class="source-date-hidden" id="source-date" value={isoDate} />}
      </p>

      {(source.data.link || isDev) && (
        <div class="source-link-wrapper">
          <a href={source.data.link || '#'} class="source-link" id="source-link-anchor" target="_blank" rel="noopener noreferrer">
            View source &rarr;
          </a>
          {isDev && (
            <span contenteditable="true" class="source-link-url" id="source-link">{source.data.link || ''}</span>
          )}
        </div>
      )}

      {computedTags.length > 0 && (
        <div class="post-tags source-tags-container" style="margin-top: 0.75rem;">
          {computedTags.map(tag => (
            <a href={`/tags/${tag.toLowerCase()}`} class="tag-link source-tag-pill">
              #{tag}
            </a>
          ))}
        </div>
      )}

    </header>

    <div class="notes-list">
      {notes.length === 0 && (
        <p class="empty-notes">
          {isDev ? 'No notes yet.' : 'No published notes yet.'}
        </p>
      )}

      {notes.map(note => (
        <div class:list={['note-card', { 'note-draft': !note.published }]} data-timestamp={note.timestamp} data-tags={JSON.stringify(note.tags)}>
          <div class="note-meta">
            <time>{new Date(note.timestamp).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</time>
            {isDev && (
              <label class="publish-toggle">
                <input type="checkbox" class="note-publish-checkbox" checked={note.published} />
                <span class="publish-toggle-slider"></span>
                <span class="publish-toggle-text">{note.published ? 'published' : 'private'}</span>
              </label>
            )}
            {isDev && (
              <button class="note-delete-btn">Delete</button>
            )}
            {note.spotify && (
              <a href={note.spotify} class="spotify-link" target="_blank" rel="noopener noreferrer">
                Spotify &rarr;
              </a>
            )}
          </div>
          {(note.tags.length > 0 || isDev) && (
            <div class="note-tags">
              {note.tags.map(tag => (
                isDev ? (
                  <span class="tag-link note-tag-pill">
                    #{tag}
                    <button class="note-tag-remove" data-tag={tag}>&times;</button>
                  </span>
                ) : (
                  <a href={`/tags/${tag.toLowerCase()}`} class="tag-link">
                    #{tag}
                  </a>
                )
              ))}
              {isDev && (
                <input class="note-tag-input" placeholder="Add tag..." />
              )}
            </div>
          )}
          <div class="note-content">
            <p contenteditable={isDev ? 'true' : undefined} class={isDev ? 'note-editable' : ''}>{note.content}</p>
          </div>
        </div>
      ))}
    </div>

    {isDev && (
      <button class="add-note-button" id="add-note-toggle">+ Add note</button>
    )}

    {isDev && <AddNotePanel slug={source.slug} />}
    {isDev && <SourceSettingsPanel slug={source.slug} archived={isArchived} />}

    <a href="/?tab=input" class="back-link">&larr; Back to sources</a>
  </div>

  {isDev && (
    <div class="edit-controls">
      <button class="settings-button" id="source-settings-button" title="Source settings">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
          <circle cx="12" cy="12" r="3"/>
        </svg>
      </button>
    </div>
  )}

  {isDev && (
    <script define:vars={{ sourceSlug: source.slug, allExistingTags }}>
      // --- Type badge click-to-cycle ---
      const typeBadge = document.getElementById('source-type');
      if (typeBadge) {
        const types = JSON.parse(typeBadge.dataset.types);
        typeBadge.addEventListener('click', () => {
          const current = typeBadge.textContent.trim();
          const idx = types.indexOf(current);
          const next = types[(idx + 1) % types.length];
          typeBadge.textContent = next;
        });
      }

      // --- Date display click-to-pick ---
      const dateDisplay = document.getElementById('source-date-display');
      const dateInput = document.getElementById('source-date');
      if (dateDisplay && dateInput) {
        dateDisplay.addEventListener('click', () => {
          dateInput.showPicker();
        });
        dateInput.addEventListener('change', () => {
          const [y, m, d] = dateInput.value.split('-');
          const dt = new Date(Number(y), Number(m) - 1, Number(d));
          dateDisplay.textContent = dt.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        });
      }

      // --- Link URL sync ---
      const linkUrl = document.getElementById('source-link');
      const linkAnchor = document.getElementById('source-link-anchor');
      if (linkUrl && linkAnchor) {
        linkUrl.addEventListener('blur', () => {
          const url = linkUrl.textContent.trim();
          if (url) {
            linkAnchor.href = url;
            linkAnchor.style.display = '';
          } else {
            linkAnchor.style.display = 'none';
          }
        });
      }

      // --- Gear button opens settings panel ---
      document.getElementById('source-settings-button')?.addEventListener('click', () => {
        window.openSourceSettings?.();
      });

      // --- Note tag editing ---
      function renderNoteTags(card) {
        const tags = JSON.parse(card.dataset.tags || '[]');
        const container = card.querySelector('.note-tags');
        if (!container) return;
        const insertTarget = container.querySelector('.note-tag-input');
        container.querySelectorAll('.note-tag-pill').forEach(el => el.remove());
        tags.forEach(tag => {
          const pill = document.createElement('span');
          pill.className = 'tag-link note-tag-pill';
          pill.textContent = '#' + tag;
          const removeBtn = document.createElement('button');
          removeBtn.className = 'note-tag-remove';
          removeBtn.dataset.tag = tag;
          removeBtn.textContent = '\u00d7';
          pill.appendChild(removeBtn);
          container.insertBefore(pill, insertTarget);
        });
      }

      async function updateNoteTags(card) {
        const tags = JSON.parse(card.dataset.tags || '[]');
        const timestamp = card.dataset.timestamp;
        try {
          const res = await fetch('/api/update-note', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ slug: sourceSlug, timestamp, action: 'update-tags', tags }),
          });
          const data = await res.json();
          if (data.success && data.sourceTags) {
            updateSourceTagsDisplay(data.sourceTags);
          }
        } catch (err) {
          console.error('Failed to update note tags:', err);
        }
      }

      // Update source-level tag display from computed tags
      function updateSourceTagsDisplay(tags) {
        const container = document.querySelector('.source-tags-container');
        if (!container) return;
        container.querySelectorAll('.source-tag-pill').forEach(el => el.remove());
        tags.forEach(tag => {
          const pill = document.createElement('span');
          pill.className = 'tag-link source-tag-pill';
          pill.textContent = '#' + tag;
          container.appendChild(pill);
        });
      }

      document.querySelector('.notes-list')?.addEventListener('click', (e) => {
        const removeBtn = e.target.closest('.note-tag-remove');
        if (!removeBtn) return;
        const card = removeBtn.closest('.note-card');
        const tags = JSON.parse(card.dataset.tags || '[]');
        const tag = removeBtn.dataset.tag;
        card.dataset.tags = JSON.stringify(tags.filter(t => t !== tag));
        renderNoteTags(card);
        updateNoteTags(card);
      });

      // --- Tag typeahead (dropdown) ---
      const tagSuggestions = [...allExistingTags]; // mutable local copy
      let dropdown = null;
      let highlightIdx = -1;
      let activeInput = null;

      function addTagToNote(input, tagValue) {
        const val = tagValue.trim().toLowerCase().replace(/^#/, '');
        if (!val) return;
        const card = input.closest('.note-card');
        const tags = JSON.parse(card.dataset.tags || '[]');
        if (!tags.includes(val)) {
          tags.push(val);
          card.dataset.tags = JSON.stringify(tags);
          renderNoteTags(card);
          updateNoteTags(card);
        }
        if (!tagSuggestions.includes(val)) {
          tagSuggestions.push(val);
          tagSuggestions.sort();
        }
        input.value = '';
        closeDropdown();
      }

      function createDropdown() {
        if (dropdown) return dropdown;
        dropdown = document.createElement('div');
        Object.assign(dropdown.style, {
          position: 'fixed',
          display: 'none',
          background: 'var(--color-background)',
          border: '1px solid var(--color-border)',
          borderRadius: '4px',
          maxHeight: '150px',
          overflowY: 'auto',
          zIndex: '200',
          minWidth: '150px',
        });
        document.body.appendChild(dropdown);
        return dropdown;
      }

      function closeDropdown() {
        if (dropdown) dropdown.style.display = 'none';
        highlightIdx = -1;
        activeInput = null;
      }

      function showDropdown(input) {
        const query = input.value.trim().toLowerCase().replace(/^#/, '');
        if (!query) { closeDropdown(); return; }

        const card = input.closest('.note-card');
        const currentTags = JSON.parse(card.dataset.tags || '[]');
        const matches = tagSuggestions.filter(t =>
          t.includes(query) && !currentTags.includes(t)
        );
        // Sort: startsWith first, then contains
        matches.sort((a, b) => {
          const aStarts = a.startsWith(query) ? 0 : 1;
          const bStarts = b.startsWith(query) ? 0 : 1;
          return aStarts - bStarts || a.localeCompare(b);
        });

        if (matches.length === 0) { closeDropdown(); return; }

        const dd = createDropdown();
        while (dd.firstChild) dd.removeChild(dd.firstChild);
        matches.forEach((tag, i) => {
          const opt = document.createElement('div');
          Object.assign(opt.style, {
            padding: '0.3em 0.6em',
            fontSize: '0.8rem',
            cursor: 'pointer',
            color: 'var(--color-text)',
          });
          opt.textContent = tag;
          opt.addEventListener('mouseenter', () => {
            opt.style.background = 'var(--color-code-bg)';
          });
          opt.addEventListener('mouseleave', () => {
            if (highlightIdx !== i) opt.style.background = '';
          });
          opt.addEventListener('mousedown', (e) => {
            e.preventDefault();
            addTagToNote(input, tag);
          });
          dd.appendChild(opt);
        });

        // Position below the input using fixed positioning
        const rect = input.getBoundingClientRect();
        dd.style.position = 'fixed';
        dd.style.top = rect.bottom + 2 + 'px';
        dd.style.left = rect.left + 'px';
        dd.style.minWidth = Math.max(rect.width, 150) + 'px';
        dd.style.display = 'block';
        highlightIdx = -1;
        activeInput = input;
      }

      function updateHighlight() {
        if (!dropdown) return;
        const opts = dropdown.children;
        for (let i = 0; i < opts.length; i++) {
          opts[i].style.background = i === highlightIdx ? 'var(--color-code-bg)' : '';
        }
        if (highlightIdx >= 0 && opts[highlightIdx]) {
          opts[highlightIdx].scrollIntoView({ block: 'nearest' });
        }
      }

      document.querySelectorAll('.note-tag-input').forEach(input => {
        input.addEventListener('input', () => showDropdown(input));

        input.addEventListener('keydown', (e) => {
          const isOpen = dropdown && dropdown.style.display === 'block' && activeInput === input;
          const opts = isOpen ? dropdown.children : [];

          if (e.key === 'ArrowDown' && isOpen) {
            e.preventDefault();
            highlightIdx = (highlightIdx + 1) % opts.length;
            updateHighlight();
          } else if (e.key === 'ArrowUp' && isOpen) {
            e.preventDefault();
            highlightIdx = highlightIdx <= 0 ? opts.length - 1 : highlightIdx - 1;
            updateHighlight();
          } else if (e.key === 'Tab' && isOpen && highlightIdx >= 0) {
            e.preventDefault();
            addTagToNote(input, opts[highlightIdx].textContent);
          } else if (e.key === 'Tab' && isOpen && opts.length > 0) {
            e.preventDefault();
            addTagToNote(input, opts[0].textContent);
          } else if (e.key === 'Enter') {
            e.preventDefault();
            if (isOpen && highlightIdx >= 0) {
              addTagToNote(input, opts[highlightIdx].textContent);
            } else if (isOpen && opts.length > 0) {
              addTagToNote(input, opts[0].textContent);
            } else {
              addTagToNote(input, input.value);
            }
          } else if (e.key === 'Escape') {
            closeDropdown();
          }
        });

        input.addEventListener('blur', () => {
          setTimeout(() => closeDropdown(), 150);
        });
      });

      // --- Note content editing (blur-to-save) ---
      document.querySelectorAll('.note-editable').forEach(el => {
        const original = el.textContent;
        el.addEventListener('blur', async () => {
          const newContent = el.textContent.trim();
          if (newContent === original.trim()) return;

          const card = el.closest('.note-card');
          const timestamp = card.dataset.timestamp;

          try {
            const res = await fetch('/api/save-source', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ slug: sourceSlug, timestamp, content: newContent }),
            });
            const data = await res.json();
            if (!data.success) {
              console.error('Failed to save note:', data.message);
            }
          } catch (err) {
            console.error('Failed to save note:', err);
          }
        });
      });

      // --- Note publish toggle ---
      document.querySelector('.notes-list')?.addEventListener('change', async (e) => {
        const checkbox = e.target;
        if (!checkbox.classList.contains('note-publish-checkbox')) return;

        const card = checkbox.closest('.note-card');
        const timestamp = card.dataset.timestamp;
        const label = checkbox.closest('.publish-toggle').querySelector('.publish-toggle-text');

        try {
          const res = await fetch('/api/update-note', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ slug: sourceSlug, timestamp, action: 'toggle-published' }),
          });
          const data = await res.json();
          if (data.success) {
            const isPublished = checkbox.checked;
            label.textContent = isPublished ? 'published' : 'private';
            card.classList.toggle('note-draft', !isPublished);
          } else {
            checkbox.checked = !checkbox.checked;
          }
        } catch {
          checkbox.checked = !checkbox.checked;
        }
      });

      // --- Note delete ---
      document.querySelector('.notes-list')?.addEventListener('click', async (e) => {
        const btn = e.target;
        if (!btn.classList.contains('note-delete-btn')) return;

        if (!window.confirm('Delete this note?')) return;

        const card = btn.closest('.note-card');
        const timestamp = card.dataset.timestamp;

        try {
          const res = await fetch('/api/update-note', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ slug: sourceSlug, timestamp, action: 'delete' }),
          });
          const data = await res.json();
          if (data.success) {
            card.remove();
          }
        } catch (err) {
          console.error('Failed to delete note:', err);
        }
      });
    </script>
  )}
</Base>

<style>
  .source-detail {
    max-width: var(--max-width);
  }

  .source-archived {
    opacity: 0.5;
  }

  .source-header {
    position: relative;
    margin-bottom: 2.5rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--color-border);
  }

  .source-title {
    font-size: 2rem;
    margin: 0.5rem 0 0.25rem;
    line-height: 1.3;
  }

  .source-title[contenteditable="true"] {
    outline: none;
    border-bottom: 1px dashed var(--color-border);
  }

  .source-title[contenteditable="true"]:focus {
    border-bottom-color: var(--color-link);
  }

  .source-author-line {
    color: var(--color-text-light);
    font-style: italic;
    margin: 0;
  }

  #source-author[contenteditable="true"] {
    outline: none;
    border-bottom: 1px dashed var(--color-border);
  }

  #source-author[contenteditable="true"]:focus {
    border-bottom-color: var(--color-link);
  }

  .source-type-editable {
    cursor: pointer;
  }

  .source-type-editable:hover {
    border-color: var(--color-link);
  }

  .source-date-display {
    /* matches italic author line */
  }

  .source-date-editable {
    cursor: pointer;
    border-bottom: 1px dashed transparent;
  }

  .source-date-editable:hover {
    border-bottom-color: var(--color-border);
  }

  .source-date-hidden {
    position: absolute;
    opacity: 0;
    width: 0;
    height: 0;
    pointer-events: none;
  }

  .source-link-wrapper {
    margin-top: 0.5rem;
  }

  .source-link {
    display: inline-block;
    font-size: 0.85rem;
    color: var(--color-text-light);
    text-decoration: none;
  }

  .source-link:hover {
    color: var(--color-link-hover);
  }

  .source-link-url {
    display: block;
    font-size: 0.75rem;
    color: var(--color-text-light);
    opacity: 0.5;
    margin-top: 0.25rem;
    outline: none;
    border-bottom: 1px dashed transparent;
    word-break: break-all;
  }

  .source-link-url:hover {
    opacity: 0.8;
    border-bottom-color: var(--color-border);
  }

  .source-link-url:focus {
    opacity: 1;
    border-bottom-color: var(--color-link);
  }

  .source-tags-container {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
  }



  .notes-list {
    margin-bottom: 2rem;
  }

  .note-card {
    padding: 1.25rem 0;
    border-bottom: 1px solid var(--color-border);
  }

  .note-draft {
    opacity: 0.7;
  }

  .note-draft .note-content p {
    color: var(--color-text);
  }

  .note-meta {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 0.75rem;
    color: var(--color-text-light);
    margin-bottom: 0.5rem;
  }

  .note-delete-btn {
    background: none;
    border: none;
    color: var(--color-text-light);
    font-size: 0.7rem;
    cursor: pointer;
    padding: 0;
    font-family: inherit;
    opacity: 0.5;
  }

  .note-delete-btn:hover {
    color: #f87171;
    opacity: 1;
  }

  .note-tags {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .note-tag-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
  }

  .note-tag-remove {
    background: none;
    border: none;
    outline: none;
    color: var(--color-text-light);
    cursor: pointer;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 0;
    line-height: 1;
    opacity: 0.5;
    -webkit-appearance: none;
    appearance: none;
  }

  .note-tag-remove:hover {
    color: #f87171;
    opacity: 1;
  }

  .note-tag-input {
    font-family: inherit;
    font-size: 0.8rem;
    background: none;
    color: var(--color-text-light);
    border: 1px dashed var(--color-border);
    border-radius: 2rem;
    padding: 0.2em 0.6em;
    width: 100px;
  }

  .note-tag-input:focus {
    outline: none;
    border-color: var(--color-link);
  }

  .note-content p {
    margin: 0;
    line-height: 1.6;
  }

  .note-editable {
    outline: none;
    border-bottom: 1px dashed transparent;
    transition: border-color 0.2s;
  }

  .note-editable:focus {
    border-bottom-color: var(--color-link);
  }

  .spotify-link {
    font-size: 0.75rem;
    color: #1db954;
    text-decoration: none;
  }

  .spotify-link:hover {
    text-decoration: underline;
  }

  .add-note-button {
    display: block;
    margin: 1.5rem 0;
    padding: 0.5rem 1rem;
    background: none;
    border: 1px dashed var(--color-border);
    border-radius: 4px;
    color: var(--color-text-light);
    cursor: pointer;
    font-family: inherit;
    font-size: 0.85rem;
  }

  .add-note-button:hover {
    border-color: var(--color-link);
    color: var(--color-link);
  }

  .empty-notes {
    color: var(--color-text-light);
    font-style: italic;
    padding: 2rem 0;
  }

  .back-link {
    display: inline-block;
    margin-top: 2rem;
    color: var(--color-text-light);
    text-decoration: none;
    font-size: 0.9rem;
  }

  .back-link:hover {
    color: var(--color-link-hover);
  }

</style>
